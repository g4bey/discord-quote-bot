from secrets import token_hex
import hikari
import lightbulb
from tinydb import Query
from utils import build_image, select_guild
from io import BytesIO
import datetime
from .errors_handling import CharacterLimitException
from .errors_handling import NoChannelAttributed
from .errors_handling import MissingParameterException
import typing
import dateutil.parser

plugin = lightbulb.Plugin("Quote-Maker")
plugin.add_checks(lightbulb.guild_only)


# -----------------------------------------------------


def veriy_field(quote: str, username: str) -> None:
    """Make sure the field have appropriate lengh"""

    if not quote:
        raise MissingParameterException('quote')

    if len(quote) > 420:
        raise CharacterLimitException(420, 'quote')

    if len(username) > 38:
        raise CharacterLimitException(38, 'username')


def get_parameters_and_check_availibity(
    ctx: lightbulb.context
) -> typing.Union[None, typing.Tuple]:
    """
    Ensure there's a channel to send the response in.
    Return the global parameter, and the hall of fame id.
    """

    guild = select_guild(ctx.guild_id)

    if not guild:
        raise NoChannelAttributed

    if not guild.get('global') and not guild.get('hall_of_fame'):
        raise NoChannelAttributed

    return guild.get('global'), guild.get('hall_of_fame')

async def handle_response(
    ctx: lightbulb.Context,
    username: typing.Union[hikari.Member, str],
    quote: str,
    type: str,
    pfp=None,
    date=None
) -> None:

    veriy_field(quote, username)
    
    guild = select_guild(ctx.guild_id)
    current_channel = ctx.get_channel().id

    if not guild:
        raise NoChannelAttributed

    global_scope = guild.get('global')
    hall_of_fame = guild.get('hall_of_fame')
    scope = guild.get('scope')
    channels = guild.get('channels')

    # nowhere to post.
    if not channels and scope != 'global' and not hall_of_fame:
        raise NoChannelAttributed

    if not pfp:
        # pfp = ctx.bot.application.icon_url  
        pfp = hikari.File("./assets/default.jpg")

    if not date:
        date = datetime.datetime.now(tz=datetime.timezone.utc)

    attachment = {}
    if type == 'image':
        avatar = BytesIO()
        async with pfp.stream() as stream:
            async for chunk in stream:
                avatar.write(chunk)

        loop = ctx.bot.d.loop
        date_txt = date.strftime("%Y-%m-%d - %H:%M:%S")
        image = await loop.run_in_executor(ctx.bot.d.process_pool, build_image, username, quote, avatar, date_txt)
        attachment['attachment'] = image
    else:
        embed = hikari.Embed(
        title=f'{username}:',
        description=quote,
        color=hikari.Color.from_hex_code(f"#{token_hex(3)}")
        )

        embed.set_thumbnail(pfp)
        
        embed.timestamp = date

        embed.set_footer(
            f'Generated by {ctx.author.username}'
        )
        attachment['embed'] = embed

    if hall_of_fame:
        await ctx.bot.rest.create_message(
            hall_of_fame,
            f'A new quote was submitted by {ctx.author.mention}',
            **attachment
        )

        if hall_of_fame != current_channel:
            if scope == 'global' or scope == 'selective' and current_channel in channels: 
                await ctx.respond('Here is your quote!', **attachment)
            # else it has to be selective.

            # sending it to the hall of fame.
            channel = ctx.get_guild().get_channel(hall_of_fame).mention
            await ctx.respond(f'You quote was sent straight to {channel}', reply=False)
        else:
            await ctx.respond("Here we go!", delete_after=0)
    elif scope == 'global' or scope == 'selective' and current_channel in channels:
        await ctx.respond('Here is your quote!', **attachment)


# -----------------------------------------------------

@plugin.command
@lightbulb.add_cooldown(15.0, 1, lightbulb.UserBucket)
@lightbulb.command(
    "quote_this",
    "Click to quote this message.",
    auto_defer=True
)
@lightbulb.implements(lightbulb.MessageCommand)
async def quote_this_cmd(
    ctx: lightbulb.MessageContext
) -> None:
    target = ctx.options.target
    avatar = target.author.avatar_url
    username = f"{target.author.username}"
    quote = target.content
    date = target.created_at

    await handle_response(ctx, username, quote,'image', avatar, date)


@plugin.command
@lightbulb.add_cooldown(15.0, 1, lightbulb.UserBucket)
@lightbulb.command(
    "embed_this",
    "Click to embed this message.",
    auto_defer=True
)
@lightbulb.implements(lightbulb.MessageCommand)
async def embed_this_cmd(
    ctx: lightbulb.MessageContext
) -> None:

    target = ctx.options.target
    avatar = target.author.avatar_url
    username = f"{target.author.username}"
    quote = target.content
    date = target.created_at

    await handle_response(ctx, username, quote, 'embed', avatar, date)


@plugin.command
@lightbulb.add_cooldown(15.0, 1, lightbulb.UserBucket)
@lightbulb.option(
    'custom_date',
    'Try using common formats!',
    required=False
)
@lightbulb.option(
    'type',
    'The bot can either generate an image, or send an embed.',
    choices=['image', 'embed']
)
@lightbulb.option(
    'author',
    'The author of the quote',
    hikari.Member,
    required=True
)
@lightbulb.option(
    'quote',
    'The text you would like to quote',
    required=True
)
@lightbulb.command(
    "quote_user",
    "Generates a quote when invoked.",
    pass_options=True,
    auto_defer=True
)
@lightbulb.implements(lightbulb.SlashCommand)
async def quote_user_cmd(
    ctx: lightbulb.Context,
    quote: str,
    author: str,
    type: str,
    custom_date: str | None = None
) -> None:

    username = f"{author.username}"
    avatar = author.avatar_url
    formarted_date = None

    if custom_date:
        try:
            formarted_date = dateutil.parser.parse(custom_date)
        except:
            await ctx.respond("Could not convert date.", delete_after=10)
            return
    else:
        formarted_date = datetime.datetime.now(tz=datetime.timezone.utc)
    
    await handle_response(ctx, username, quote, type, avatar, formarted_date)


@plugin.command
@lightbulb.add_cooldown(15.0, 1, lightbulb.UserBucket)
@lightbulb.option(
    'custom_date',
    'Try using common formats!',
    required=False
)
@lightbulb.option(
    'type',
    'The bot can either generate an image, or send an embed.',
    choices=['image', 'embed']
)
@lightbulb.option(
    'quote',
    'The text you would like to quote',
    required=True
)
@lightbulb.command(
    "quote_me",
    "Generates a quote when invoked.",
    pass_options=True,
    auto_defer=True
)
@lightbulb.implements(lightbulb.SlashCommand)
async def quote_me_cmd(
    ctx: lightbulb.Context,
    quote: str,
    type: str,
    custom_date: str | None = None
) -> None:

    author = ctx.author
    username = f"{author.username}"
    avatar = ctx.author.avatar_url

    if custom_date:
        try:
            formarted_date = dateutil.parser.parse(custom_date)
        except:
            await ctx.respond("Could not convert date.", delete_after=10)
            return
    else:
        formarted_date = datetime.datetime.now(tz=datetime.timezone.utc)
    
    await handle_response(ctx, username, quote, type, avatar, formarted_date)



@plugin.command
@lightbulb.add_cooldown(15.0, 1, lightbulb.UserBucket)
@lightbulb.option(
    'custom_date',
    'Try using common formats!',
    required=False
)
@lightbulb.option(
    'type',
    'The bot can either generate an image, or send an embed.',
    choices=['image', 'embed']
)
@lightbulb.option(
    'quote',
    'The text you would like to quote',
    required=True
)
@lightbulb.option(
    'author',
    'The author of the quote',
    default='anonymous-wolf'
)
@lightbulb.command(
    "quote_anon",
    "Generates a quote when invoked.",
    pass_options=True,
    auto_defer=True
)
@lightbulb.implements(lightbulb.SlashCommand)
async def quote_anon_cmd(
    ctx: lightbulb.Context,
    type: str,
    quote: str, author:
        typing.Optional[str] = None,
    custom_date: str | None = None
) -> None:

    if custom_date:
        try:
            formarted_date = dateutil.parser.parse(custom_date)
        except:
            await ctx.respond("Could not convert date.", delete_after=10)
            return
    else:
        formarted_date = datetime.datetime.now(tz=datetime.timezone.utc)
    
    await handle_response(ctx, author, quote, type, ctx.bot.application.icon_url, formarted_date)


# -----------------------------------------------------


def load(bot: lightbulb.BotApp) -> None:
    bot.add_plugin(plugin)


def unload(bot: lightbulb.BotApp) -> None:
    bot.remove_plugin(plugin)
